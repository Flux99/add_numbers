00:00:01	all right everyone I am home alone again which means I was faced with a very tough decision AKA either whip out the or record Another YouTube video and uh I guess I'm deciding to feel productive at the moment so I will be talking about Cassandra in this one I've been looking forward to this video for a couple of weeks because I find that um you know like I said the whole reason I made this channel in the first place was that they don't go that in depth into actual Technologies in most systems design

00:00:27	channels or resources looking at things like systems expert. like you know there's just like no in-depth stuff about specific Technologies and I pretty much want to go through every popular database and compare its pros and cons because I think you're going to look pretty damn smart if in an interview you can actually compare why you might use something like Cassandra vers ryak or I don't know mongod DB or anything so anyways let's get into it um and then uh yeah we can uh keep going into more Technologies and more deep dives into

00:00:56	Concepts all righty so episode 19 this one is about Apache Cassandra so what is Cassandra it is a nosql wide column database designed for really high read and especially write throughput um it was created at Facebook modeled after things like Amazon's Dynamo database and Google's big table and it's since become open source under the Apache License um so yep like I said really high right throughput no SQL database pretty simple stuff I'm now going to get into how it goes ahead and does all of that because

00:01:28	it builds upon all the concepts that we've discussed so far okay so what is the general design philosophy of Cassandra well generally speaking obviously they want super high availability you know the ability to scale at a linear rate meaning every single time you add a node it's going to you know do that much work and you know get all of its possible throughput um but most importantly the thing with Cassandra is that unlike SQL um it is designed solely for single partition reads and wres it doesn't mean that you

00:01:58	can't do reads over say multiple partitions or can't write to multiple partitions at a time but generally speaking the main usages of a data database like this are to try and keep everything onto one partition so that you don't have that extra Network delay and coordination overhead required of something like an atomic commit or having to do all these multiple partition rights so like I said Cassandra is optimized for a single partition um operation okay so in terms of data organization like I said this is

00:02:28	a wide column store so what that means really is that you have a primary key or what Cassandra calls it is known as a partition key and a bunch of other columns which are basically arbitrary you can also specify in your Cassandra setup some other columns known as um clustering keys but uh those are basically um acting as indexes and I'll discuss those later okay so in terms of the storage engine like I said Cassandra is optimizing for really fast rights because in certain applications with a ton of us users you need to be able to

00:03:01	write quickly and SQL doesn't always support that especially because of the fact that it uses be trees so if you've watched my first video on this channel I discuss the different ways that databases handle reads and writes and there are two main types of engines B tree based and also LSM tree based Cassandra goes ahead and uses an LSM tree based table the reason that these are so fast is because it means that rights get buffered to an inmemory uh Tree in addition uh you know the the downside of

00:03:31	this is that depending on how often log compactions performed remember that every single right goes into this table even if it's just an update and then eventually we'll get compacted to only um contain the most updated version of a key but again depending on how often L uh log compaction is performed and this is something that uses a bunch of CPU resources in the back um you know obviously updates can take a decent amount of extra disc space as a result of that additionally performance of reads compared to be trees can be a

00:03:59	little bit slower if you need to search through a key through the SS tables but Cassandra does use an algorithm called Bloom filters which basically is an optimization on um doing these reads because it approximates the contents of a set and that way you can guess if an SS table contains a specific key okay in terms of partitioning why is Cassandra good um well Cassandra uses the partitioning key in accordance with um consistent hashing so I literally covered this two videos ago as a prerequisite for this video in order to

00:04:31	basically say the consistent hashing tries to um put all of the the partitions on machines in a way such that when new nodes are added or nodes are removed from a cluster there's minimal rebalancing of rows okay so hopefully that makes sense in terms of replication this is where Cassandra is really really um making uh for good right speeds it's a Dynamo style database so what that means is that every single right as opposed to just being sent to one liter node is being sent to every single node in the cluster

00:04:59	for that partition so what that means though is that um you know obviously a that can introduce conflicts and B it's a question of well at what point after hearing from all of these uh nodes do we actually tell our client that a right was successful and the answer to that second question um is that rights are only reported back to the client as successful once a right reaches a number of nodes that is preconfigured by the database administrator Cassandra has a ton of options for this so you can

00:05:29	either just hit literally any one node you can hit um you know say a quorum of nodes but only in your local data center you can hit an actual Global Quorum of nodes and there are a bunch of options for this so you know you can kind of configure that to get the consistently consistency level that you want um additionally just by virtue of being a um replication setup where there are multiple leaders it means that they're going to be conflicting rights so how do we handle these well we use last right

00:05:56	wins last right wins means that um you know based on the higher time step uh based on the higher Tim stamp whichever one was the more recent right is the one that is kept however the issue here is that if you've seen my videos in the past clocks are not reliable in distributed systems servers are inherently going to be a little bit out of sync Cassandra doesn't really have a great answer to this all they basically say is keep your servers as close to the proper time as possible via the ntp network time protocol syncing mechanism

00:06:25	and um that's really all you can do there another thing that means is that certain rights might just be lost if you're going to update a key and then someone else updates it literally a millisecond later so uh that is just a downside of all this there's no like merge handling or anything like that um additionally there is read repair on reads in order to keep the data consistent so if you have um two nodes where one of them is holding an older version of a row based on the time stamp and a client reads from both of those

00:06:55	replicas because um all reads are going to multiple replicas uh the client will go head and perform read repair and give the replica with the outdated version of the row the newer version of the row um additionally and this is what um is really done to guarantee eventual consistency is that Cassandra runs an anti-entropy process which means that in the background um the replicas are going to be uh kind of calculating the differences between them in terms of their contents and then one replica will

00:07:22	help to update another to make sure it has the most up-to-date versions of all the data okay and then the final thing is that um you know in ordered to in accordance with kind of replication Dynamo style databases and just keeping things available if for some reason the replicas can't handle rights in a given moment perhaps um you know they are overloaded or they're down the coordinator node that is going to actually be sending the rights to the replicas will just store the right for a period of time and then eventually store

00:07:50	them in the replica when the replicas are back up that's known as a hinted handoff I've used that term in the past okay in terms of fault tolerance well like I said the data is stored on repli because which is generally the way that you do handle fall tolerance and that's in this case both good for writes and reads because writs only have to go to a certain percentage of the nodes reads only go to a certain percentage of the nodes and then the data is redundant via the replicas uh the replicas should allow

00:08:15	read and write throughput to scale linearly with the number of replicas like I mentioned earlier and then also a cool thing about Cassandra is that you can actually choose the replication topology so what that means is not only can you choose how many nodes is a given piece of data replicated to but also the location of which nodes it's going to be replicated to so say you want to ensure that um if an entire server Rack or an entire data center goes down and at least one replica will still be standing

00:08:42	with that data you can actually use a replication topology that ensures that only nodes and say like different physical locations are being replicas one another additionally um in terms of detecting faults in uh in nodes we use a gossip protocol to do that that was the subject of the last video on this channel and basically all that happen is nodes are going to keep track of heartbeats that they get from other nodes and then each node locally is holding what it assumes to be the last known heartbeat of every single other

00:09:10	node which they pass around via this gossip protocol and if the time stamp takes too long or or it's been too long since a node has sent out a heartbeat uh you know the local node will assume that other remote node to be dead Okay indexes uh indexes are a really important part of you know ensuring fast read performance and it's something I've talked about on the past in this channel the thing is though in terms of indexes Cassandra does not let you do any Global secondary indexes what does that mean it means that there's

00:09:40	like I said no index to quickly um filter based on say some column that isn't the primary key and do so in a way that it touches all partitions those indexes are local only which means they only apply to one partition at a time so in order to do these Cassandra is allowing you to index based on those clustering keys and so what it'll do is it'll sort internally um if you have multiple clustering Keys such that you know you want to keep multiple copies of the sorted data Cassandra will actually denormalize the data and duplicate it on

00:10:12	a given node such that um now you have two copies of the data sorted in two different ways the one issue with this is even though reads are now going to be faster for that um value of the clustering key um the issue here is that now rights are going to take longer because we're updating two copies of the data at once okay so now let's actually talk about the use cases for Cassandra because like I said there are sometimes where it's not always the perfect solution there's no database that's always the right

00:10:41	answer but Cassandra can be the right answer a lot of the time so let's discuss when it is big thing as you can see I've got it written in all caps right here write heavy applications so if data is generally self-contained which you should be able to do because or I shouldn't say you should be able to do but if there's little relationships uh within each piece of data and you know you can kind of keep it all into one row and keep in mind Cassandra allows you to use pretty complex data structures in the rows like arrays and

00:11:08	sets and all of these things so if you can keep all the data to one row and rarely have any associations with things in another partition or another table and in addition it only needs to be generally fetched by itself then Cassandra might be the solution for you so what are examples of this things like sensor readings you would use the same partition key for the same exact sensor and then all the readings from that sensor are going to be on the same partition and then perhaps you would use a clustering uh

00:11:35	you know like an ordering key like a Tim stamp so that you could order them quickly by time and then filter that way same goes for chat messages perhaps a partition key would be like the chat ID and then Tim stamp of the message again in order to sort them properly and then the same goes for user activity tracking use the user ID as the partition key and then again timestamp furthermore so as you can see all of these applications right here were you're just taking in like a huge list of data and you're

00:12:02	really just going to basically grab chunks of that list it's really great for Cassandra and of course in any application there's inevitably going to be many databases used so it's fine if for say you just want to use Cassandra for say like let's do Facebook Messenger Cassandra for the messages but then you use a relational database for actually like the users and the members of a given chat so you know you would have a chat ID that's specified somewhere in the relational table and then you would

00:12:30	actually be holding all of the chat messages and something like Cassandra that would be a great place to use it okay so in conclusion Cassandra is really good for right heavy applications at massive massive scale um it can scale a lot because you can just add nodes and then the fact that they're using this Dynam inspired um design just allows you to go ahead and make more rights to different nodes you've got anti-entropy in order to keep everything eventually consistent um so like I said messaging

00:12:59	sensory ings activity tracking great uh the pitfalls on the other hand are the lack of strong consistency yes you can always use Quorum reads and rights however uh the issue there is like I said even quorums themselves aren't strongly consistent due to race conditions and the fact that there's hinted handoff and the fact that sometimes um you know if you make a right to um like a quorum of nodes but you don't actually hit that like Quorum threshold of nodes then do we revert the right on the existing nodes that the

00:13:31	rights exceeded on or not so quorums aren't perfect just keep that in mind even if you do want strong consistency here and then secondly obviously if you want to support things like one to many relationships and many many to many relationships especially spanning multiple partitions Cassandra is probably not going to be the thing for you and then finally we also have a lack of global secondary indexes so in some very specific read heavy applications where you really want to be optimizing on read performance and say like a cash

00:14:01	isn't going to work for you then Cassandra probably isn't the move and we're going to have to examine other options for those well guys like I said I hope um this video is useful I really hope that uh these like actual specific technology breakdowns are kind of the differentiator between my channel and other existing systems design videos because I just don't think they go in depth enough in terms of actual real world applications and I think that being able to know these things would really set you apart in a real systems

00:14:27	design interview

